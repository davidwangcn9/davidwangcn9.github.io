---
layout:     post
title:      集成支付网关的三两事
subtitle:   支付交付
date:       2022-10-08
author:     大风哥
header-img: img/fraudpayment.png
catalog: true
tags:
    - 支付
    - 支付网关
    - 集成
    - 卡支付
---

* [支付涉及重要概念](#支付涉及重要概念)
    * [PAN data](#pan-data)
    * [CardHolder Data](#cardholder-data)
    * [PCI DSS](#pci-dss)
* [支付网关的集成方式](#支付网关的集成方式)
* [重复支付](#重复支付)
* [常见问题](#常见问题)

# 支付涉及重要概念
## PAN data
Primary Account Number (PAN) 指的就是卡号，唯一的支付卡号（信用卡，借记卡），用于唯一标识发卡行和持卡人的账号。

## CardHolder Data
CardHolder Data指持卡人信息，包含PAN，持卡人姓名，过期时间，CVV等。
![pic](/img/gateway-CHD.png)
这些都是卡支付中最重要的数据，如果读过我之前文章（支付欺诈与3DS），会知道丢失CardHolder Data是有可能造成支付欺诈并对不同群体造成严重影响的。再由于支付系统间或多或少会涉及到传输，存储，打印卡数据，所以卡数据的妥善处理是支付中非常重要的一环。很多的工作都会围绕如何保证用户卡数据的安全与私密而展开，并且每年会有非常严格的审核来保障系统中每个环节都达到了安全基线。这也是后面提到的PCI DSS。

## PCI DSS
上面提到的CardHolder Data其实就叫做PCI数据。是不是听人说过PII数据或者PI数据，大家也都大概知晓保证PII数据与隐私的重要性，其实PCI数据是比PII更为敏感的数据，更需要重视。丢失PII数据可能会失信于产品，而丢失PCI数据则可能失信于整个行业，所以PCI数据安全至关重要。
为了保证数据的安全，卡组织推出一套支付卡产业数据安全标准Payment Card Industry Data Security Standard (PCI DSS) 来提高持卡人数据安全标准。 这套标准采用全球化一致的数据安全措施，并提供了一套保护持卡人数据的技术和操作的一些列基线要求。
搞过支付交付的小伙伴，或多或少可能都接触过PCI DSS，取决于你负责的系统与PCI Data的交互程度。交互程度怎么描述呢？如下图
![pic](/img/gateway-pcidss.png)
只要是有PCI数据流经你所负责的系统，不管你的系统如何处理的PCI数据（甚至没有处理），都会被认定为需要接受每年PCI审计的系统，而且根据你的系统所参与处理PCI数据的程度，会有不同的PCI定级，所需要审计回答的问题数量也是由此大不相同，当然除了回答PCI组织的问题，还需要根据要求提升基础设施的安全等级，维护漏洞管理程序，实施严格的存储控制措施，定期监控并测试网络，提升软件版本，同时还要提供证据证明你的系统是安全可靠，没有数据丢失的风险的。以下是PCI审计的全过程：
1. 准备评估，并与评审员初步确定PCI等级   （SAQ-A有 22 问题， SAQ-D有 329 问题）
2. 文档工作，网络系统改造
3. 文档审核
4. 现场审核
5. 报告完成并提交

对于最轻的SAQ-A 之前有参与过，这个算是PCI审计中最轻的，不过即使这样，也需要至少走前三个流程，还是比较花时间和精力的。那么什么样的系统算SAQ-A呢，即没有PCI数据真实流进的系统。
怎么说呢，这种系统就是后面提到的使用支付网关提供的host payment page（iframe形式）直接集成的前端的一种集成方式的系统，PCI数据会直接从发给支付网关，不会流经我们的系统。后面会有详细介绍。
 
至于最重的SAQ-D，开发维护过支付网关的朋友们，应该是最深有感触的，每年做PCI审计感觉都会掉一层皮。我们之前一个兄弟团队就是做支付网关维护的，每年大概需要5个月左右投入到PCI审计中，耗时又耗力。所以如果可以选择，最好将产品直接集成现成的支付网关，正所谓让专业的人做专业的事，这样省心且高效。

# 支付网关的集成方式
支付网关，是所有做支付相关交付工作绕不开的重要元素，它负责真正的支付行为并与底层的acquirer（支付机构），卡组织（visa，mastercard）打交道。当然，不少团队的工作就是去集成现有的市场上的支付网关，毕竟很少有公司愿意自己花时间和精力开发并维护自己的的支付网关了，而且一旦自己开发维护，就要承担责任，负责满足每年的PCI审计。
 
所以如何才可以更快，更好的集成支付网关的集成，并用最优雅且PCI footprint最轻的方式进行集成就是所有交付团队需要考虑的问题。如果交付团队会参与到支付网关的选取，那么支付网关提供的集成方式也是需要考量的因素。总的来说，目前市场上的支付网关大的集成方式主要有这么以下几种：
* 深度集成，使用深度API，PCI数据流经集成系统
* Host Payment Page, 将支付网关提供的iFrame嵌入到网页中，PAN数据不会流进集成系统
* 即插即用，跳转至支付网关提供的页面进行支付

第一种，深度集成会导致PCI数据流经系统，但是好处是更大的自由度，可以对支付数据深加工，并且可以在支付流程中有更多的控制能力。但是这种集成方式一般是不推荐的，原因无它，就是PCI footprint太深，会导致每年大量时间的金钱花在PCI审计上，降低产品的竞争力，PCI审计上花的资源将慢慢成为产品的一个重大负担。
第二种，host payment page这种形式应该可以说是最为推荐的，也是我们实际项目中经常采用的方式。一般直接使用支付网关提供的iframe嵌入到我们系统的网页中，好处非常明显，就是PCI数据不会流进我们系统，而且可以做到一定程度的branding，有钱的公司有可能会和支付网关vendor进行深度定制，使得iframe的UI风格与外部风格一致。即使使用这种方式，还是需要每年接受上面说的SAQ-A的PCI审计。（PCI审计是逃不了的）
第三种，即插即用，这种的受众群体一般是快餐式网站，它们不要求支付网页branding，不要求用户的支付体验，即用户在支付时会跳转到支付网关提供的一个网站进行支付。这种集成一般最为轻量级。但是作为要面子的大公司，都不会采纳的方式。
 
总之，推荐的就是host payment page这种方式，如下图
![pic](/img/gateway-iframe.png)
如上图举的例子，红色框的iframe即为支付网关提供的，我们只是把它内嵌到我们网站中，所以内部的UI，事件我们都没法控制，同时当用户输完CardHolder Data后，数据会直接发送到支付网关。

# 重复支付
支付交付项目中的问题还是很多的，由于是和钱打交道，所以对安全，高可用，数据同步都有很高的要求。
然而重复支付似乎是所有系统或多或少都会遇到的问题，归根到底都是数据不同步导致。如何保证数据在商家，支付网关，支付处理机构是一致，是一个非常深刻的问题，或者说是一个分布式计算存在的普遍问题。
 
在支付的场景里如何解决，主要的方式不外乎两类：
* 事前， 即为尽可能的使用各种技术设计框架进行预防
* 事后，其实解决办法很简单，发起内部退款，将多余支付的一笔反向退款回去。

是不是觉得事后方式太low。 No，no，no，眼光需要拔高一些，从整个产品运维的角度去看，在使用流程化的人工来解决一些偶发问题，有时会比加固优化系统来考虑某种edge case更为经济与实惠。毕竟产品是用来赚钱的。不能一味的追求just so so technology，需要从产品运维成本与产品设计卓越中寻求一个完美的平衡。
当然我们这里还是专注于事前预防的方案。在聊具体方案前，还是先讲清楚重复支付是如何发生的，如下图：
![pic](/img/gateway-duplicate.png)
在第3步支付网关返回支付结果时超时了，这个时候如果我们的系统（在线商城）没有很好的处理这次支付，就有可能让客户以为支付没有成功，从而有可能会重新支付一笔，从而造成重复支付。
其实这个时候有可能很很多中可能性：
1. 由于网络原因，支付网关根本没有收到第2步支付请求
2. 支付网关收到了请求，但是由于某些原因没能正常处理支付，也就是支付失败了，同时由于各种原因导致超时
3. 支付网关收到了请求，并且成功处理了支付，可是由于网络原因（服务器满载），导致超时

不管是哪一种，在线商城在同步调用中都不清楚这笔支付的支付状态，那么作为在线商城又如何呈现给它的用户了。苦等？显示支付失败？还是如何呢？如果这个时候系统不管三七二十一按照错误处理，那么就有可能造成重复支付了。
如何保证支付状态的一致性呢？（黑马的小伙伴可能会说采用AP方案，加个message queue，可是在现实中，支付网关一般是不会提供的，毕竟它是外部系统）
以下是我总结出来的比较容易落地的方案：
![pic](/img/gateway-duplicate-sln.png)
其实理解起来也比较容易，我们把支付用状态机来控制，而支付会在不同状态中转化，其中终态只有两个，支付成功或者支付失败。还有一点需要注意的是，我们作为支付网关集成方，一定需要慎重的与支付网关规定一个等待超时时间（不能一直苦等结果），一旦发生了支付超时情况，则通过第4步告知用户支付处理中，同时通过与支付网关协商的获取最终状态方式来获取支付结果，直到获取到结果将支付状态标记为成功或者失败。与支付网关获取最终结果的方式，一般会有两种方式
1. 支付网关提供callback，在支付时，我们将callback传给支付网关等待支付网关的异步返回。
2. 支付网关提供查询接口，在支付超时后，我们可以通过不断的查询来实现最终获取状态的办法。

当然了，如果由于网络原因，支付网关真的没有收到请求，我们也不可能一直等callback或者query，还是需要设定一个等待预设值（与支付网关商量好），在超过这个预设值后，就直接返回支付失败。事无绝对，这种情况下还是有可能有重复支付，不过从概率上大大降低，只有在极端情况下出现，可以使用前面讲的事后方案来“殿后”。
 
以下是考虑重复支付时通过经验与实践总结出来的checklist：
* 进行威胁建模， 画DFD（Data flow diagram），考虑可能出现的问题
    * 考虑error case，考虑edge case，考虑最坏情况下如何自动/人工恢复
* 及早与支付网关确定支付调用最大超时时间
* 与支付网关商讨最有效的获取支付最终结果的方式方法
* 完善定义支付的状态机，合理定义处理中状态，用于处理超时情况
* 与支付网关确认3秒内正常返回支付结果的百分比（由此可以推出可能发生异常的百分比）

# 常见问题
支付中还有一些很常见的坑与问题，对于初入此道者往往容易掉进去，所以以下这些反向操作就作为警示了。切勿模仿！
* HTTPS已经非常安全了，就不需要什么参数签名了
    * https的有效范围一般局限于外网或者说证书所在服务器, 是无法保证内网的，一般情况下，内网服务间还是用的http，所以参数签名防篡改如果可以有，还是要加上的
* 只要支付网关返回200，直接修改支付状态为成功，一定不需要验证扣款金额是否与送款金额一致
    * 支付网关，或者说下游支付机构返回的结果可能与我们期待不同，之前有人见过返回200，结果response金额比request金额要少的情况，这种情况下如果不校验，你的产品就只能自己当冤大头了。
* 支付流水号用时间戳就可以了，咋方便咋来
    * 这个应该显而易见
* 支付网关，支付系统都非常稳定，我们集成方不太需要考虑这个错误场景
    * 不考虑错误场景，一旦发生将造成不可弥补的损失。永远不要过度相信支付网关，更何况中间和隔离一个不可信任的网络。对于支付，考虑再仔细都不为过
* 支付时让前端直接发送支付请求就可以了，不需要再到后端校验送款金额
    * 永远不要给自己设计的系统留下后门，金额必须通过后端校验，不然被卖了还在给别人数钱。